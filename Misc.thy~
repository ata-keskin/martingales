theory Misc
  imports "HOL-Analysis.Measure_Space" "HOL-Analysis.Bochner_Integration" "HOL-Analysis.Set_Integral"
begin

lemma banach_simple_function_indicator_representation:
  fixes f ::"'a \<Rightarrow> 'b :: {second_countable_topology, banach}"
  assumes f: "simple_function M f" and x: "x \<in> space M"
  shows "f x = (\<Sum>y \<in> f ` space M. indicator (f -` {y} \<inter> space M) x *\<^sub>R y)"
  (is "?l = ?r")
proof -
  have "?r = (\<Sum>y \<in> f ` space M.
    (if y = f x then indicator (f -` {y} \<inter> space M) x *\<^sub>R y else 0))" by (auto intro!: sum.cong)
  also have "... =  indicator (f -` {f x} \<inter> space M) x *\<^sub>R f x" using assms by (auto dest: simple_functionD)
  also have "... = f x" using x by (auto simp: indicator_def)
  finally show ?thesis by auto
qed

lemma bochner_integrable_induct[consumes 1, case_names cong set add seq]:
  fixes P :: "('a \<Rightarrow> 'b :: {second_countable_topology, banach}) \<Rightarrow> bool"
  assumes u: "integrable M u"
  assumes cong: "\<And>f g. integrable M f \<Longrightarrow> integrable M g \<Longrightarrow> (\<And>x. x \<in> space M \<Longrightarrow> f x = g x) \<Longrightarrow> P g \<Longrightarrow> P f"
  assumes set: "\<And>A y. A \<in> sets M \<Longrightarrow> emeasure M A < \<infinity> \<Longrightarrow> P (\<lambda>x. indicator A x *\<^sub>R y)"
  assumes add: "\<And>u v. P u \<Longrightarrow> P v \<Longrightarrow> P (\<lambda>x. u x + v x)"
  assumes seq: "\<And>s. (\<And>i. Bochner_Integration.simple_bochner_integrable M (s i)) \<Longrightarrow> (\<And>i. P (s i)) \<Longrightarrow> ((\<lambda>i. \<integral>\<^sup>+x. norm (u x - s i x) \<partial>M) \<longlonglongrightarrow> 0) \<Longrightarrow> P u"
  shows "P u"
proof-
  obtain I where "has_bochner_integral M u I" using u integrable.cases by auto
  then obtain s where s_is: "Bochner_Integration.simple_bochner_integrable M (s i)" "((\<lambda>i. \<integral>\<^sup>+x. norm (u x - s i x) \<partial>M) \<longlonglongrightarrow> 0)" for i using has_bochner_integral.cases by force
        
  have s_simple: "simple_function M (s i)" for i using s_is simple_bochner_integrable.simps by blast

  have "s i -` {0} \<inter> space M \<in> sets M" for i using simple_functionD[OF s_simple] by blast
  hence "space M - (s i -` {0} \<inter> space M) \<in> sets M" for i by blast
  moreover have "{x \<in> space M. s i x \<noteq> 0} = space M - (s i -` {0} \<inter> space M)" for i by blast
  moreover have "emeasure M {x \<in> space M. s i x \<noteq> 0} \<noteq> \<infinity>" for i using s_is simple_bochner_integrable.simps by blast
  moreover have "s i -` {y} \<inter> space M \<subseteq> {x \<in> space M. s i x \<noteq> 0}" if "y \<noteq> 0" for i y using that by fast
  ultimately have "emeasure M (s i -` {y} \<inter> space M) < \<infinity>" if "y \<noteq> 0" for i y by (metis (no_types, lifting) emeasure_mono that infinity_ennreal_def linorder_not_less top.not_eq_extremum)
  hence P_set: "P (\<lambda>x. indicator (s i -` {y} \<inter> space M) x *\<^sub>R y)" if "y \<noteq> 0" for i y using set s_simple simple_functionD(2) that by meson
  
  have P_add: "P (\<lambda>x. \<Sum>y \<in> F. indicator (s i -` {y} \<inter> space M) x *\<^sub>R y)" if "finite F" "F \<subseteq> s i ` space M" for i F using that
  proof (induction rule: finite_induct)
    case empty
    then show ?case using set[of "{}"] by simp
  next
    case (insert x F)
    hence asm: "F \<subseteq> s i ` space M" by fast
    have *: "(\<Sum>y\<in>insert x F. indicat_real (s i -` {y} \<inter> space M) z *\<^sub>R y) = indicat_real (s i -` {x} \<inter> space M) z *\<^sub>R x + (\<Sum>y\<in>F. indicat_real (s i -` {y} \<inter> space M) z *\<^sub>R y)" for z using insert(2) by (subst sum.insert_remove[OF insert(1)], auto)
    show ?case
    proof (cases "x = 0")
      case True
      show ?thesis using * by (fastforce simp add: insert(3)[OF asm] True)
    next
      case False
      show ?thesis using * insert(3)[OF asm] P_set[OF False, of i] add by presburger
    qed
  qed

  have s_i_integrable: "integrable M (s i)" for i by (simp add: integrableI_simple_bochner_integrable s_is(1))
  moreover have s_i_rep: "s i x = (\<Sum>y \<in> s i ` space M. indicator (s i -` {y} \<inter> space M) x *\<^sub>R y)" if "x \<in> space M" for x i using banach_simple_function_indicator_representation[OF s_simple that] by blast
  moreover have "integrable M (\<lambda>x. \<Sum>y \<in> s i ` space M. indicator (s i -` {y} \<inter> space M) x *\<^sub>R y)" for i using s_i_rep s_i_integrable by (rule integrable_cong[OF refl, of M "s i", THEN iffD1], blast)
  ultimately have "P (s i)" for i using cong P_add[OF simple_functionD(1)[OF s_simple] order.refl] by meson
  thus ?thesis using seq s_is by blast
qed

lemma set_integral_scaleR_left[simp]: 
  assumes "A \<in> sets M" "c \<noteq> 0 \<Longrightarrow> integrable M f"
  shows "LINT t:A|M. f t *\<^sub>R c = (LINT t:A|M. f t) *\<^sub>R c"
  unfolding set_lebesgue_integral_def 
  using integrable_mult_indicator[OF assms]
  by (subst integral_scaleR_left[symmetric], auto)

lemmas simple_function_scaleR[intro, simp] = simple_function_compose2[where h="(*\<^sub>R)"]

end